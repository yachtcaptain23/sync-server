// Code generated by protoc-gen-go. DO NOT EDIT.
// source: encryption.proto

package sync_pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Encrypted sync data consists of two parts: a key name and a blob. Key name is
// the name of the key that was used to encrypt blob and blob is encrypted data
// itself.
//
// The reason we need to keep track of the key name is that a sync user can
// change their passphrase (and thus their encryption key) at any time. When
// that happens, we make a best effort to reencrypt all nodes with the new
// passphrase, but since we don't have transactions on the server-side, we
// cannot guarantee that every node will be reencrypted. As a workaround, we
// keep track of all keys, assign each key a name (by using that key to encrypt
// a well known string) and keep track of which key was used to encrypt each
// node.
type EncryptedData struct {
	KeyName              *string  `protobuf:"bytes,1,opt,name=key_name,json=keyName" json:"key_name,omitempty"`
	Blob                 *string  `protobuf:"bytes,2,opt,name=blob" json:"blob,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptedData) Reset()         { *m = EncryptedData{} }
func (m *EncryptedData) String() string { return proto.CompactTextString(m) }
func (*EncryptedData) ProtoMessage()    {}
func (*EncryptedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8293a649ce9418c6, []int{0}
}

func (m *EncryptedData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptedData.Unmarshal(m, b)
}
func (m *EncryptedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptedData.Marshal(b, m, deterministic)
}
func (m *EncryptedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedData.Merge(m, src)
}
func (m *EncryptedData) XXX_Size() int {
	return xxx_messageInfo_EncryptedData.Size(m)
}
func (m *EncryptedData) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedData.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedData proto.InternalMessageInfo

func (m *EncryptedData) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

func (m *EncryptedData) GetBlob() string {
	if m != nil && m.Blob != nil {
		return *m.Blob
	}
	return ""
}

func init() {
	proto.RegisterType((*EncryptedData)(nil), "sync_pb.EncryptedData")
}

func init() {
	proto.RegisterFile("encryption.proto", fileDescriptor_8293a649ce9418c6)
}

var fileDescriptor_8293a649ce9418c6 = []byte{
	// 144 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x48, 0xcd, 0x4b, 0x2e,
	0xaa, 0x2c, 0x28, 0xc9, 0xcc, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x2f, 0xae,
	0xcc, 0x4b, 0x8e, 0x2f, 0x48, 0x52, 0xb2, 0xe3, 0xe2, 0x75, 0x85, 0x48, 0xa6, 0xa6, 0xb8, 0x24,
	0x96, 0x24, 0x0a, 0x49, 0x72, 0x71, 0x64, 0xa7, 0x56, 0xc6, 0xe7, 0x25, 0xe6, 0xa6, 0x4a, 0x30,
	0x2a, 0x30, 0x6a, 0x70, 0x06, 0xb1, 0x67, 0xa7, 0x56, 0xfa, 0x25, 0xe6, 0xa6, 0x0a, 0x09, 0x71,
	0xb1, 0x24, 0xe5, 0xe4, 0x27, 0x49, 0x30, 0x81, 0x85, 0xc1, 0x6c, 0x27, 0x6d, 0x2e, 0xd5, 0xfc,
	0xa2, 0x74, 0xbd, 0xe4, 0x8c, 0xa2, 0xfc, 0xdc, 0xcc, 0xd2, 0x5c, 0xbd, 0xe4, 0xfc, 0xdc, 0x82,
	0xfc, 0xbc, 0xd4, 0xbc, 0x92, 0x62, 0x3d, 0x90, 0x15, 0x10, 0xeb, 0x92, 0xf3, 0x73, 0x3c, 0x98,
	0x03, 0x18, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x59, 0xff, 0xa2, 0x88, 0x00, 0x00, 0x00,
}
